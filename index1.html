<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <title>OCR HTML Thu·∫ßn ‚Äì ·ªîn ƒê·ªãnh</title>

    <!-- Tesseract v5 -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            max-width: 900px;
            margin: auto;
        }

        img,
        canvas {
            max-width: 50%;
            margin-top: 10px;
            border: 1px solid #ccc;
            display: block;
        }

        textarea {
            width: 100%;
            height: 220px;
            margin-top: 10px;
            font-family: Consolas, monospace;
            white-space: pre-wrap;
        }

        .box {
            border: 1px solid #ddd;
            padding: 10px;
            margin-top: 15px;
        }
    </style>
</head>

<body>

    <h2>OCR HTML + JS (ƒê·ªçc to√†n b·ªô vƒÉn b·∫£n trong ·∫£nh)</h2>

    <input type="file" id="file" accept="image/*,.pdf">

    <div class="box">
        <b>·∫¢nh g·ªëc</b>
        <img id="preview">
    </div>

    <div class="box">
        <b>·∫¢nh x·ª≠ l√Ω (OCR input)</b>
        <canvas id="canvas"></canvas>
    </div>

    <p id="status">Ch∆∞a c√≥ ·∫£nh</p>

    <div class="box">
        <b>OCR RAW</b>
        <textarea id="result"></textarea>
    </div>

    <script>
        const fileInput = document.getElementById("file");
        const preview = document.getElementById("preview");
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const status = document.getElementById("status");
        const result = document.getElementById("result");

        fileInput.onchange = async () => {
            const file = fileInput.files[0];
            if (!file) return;

            result.value = "";
            status.innerText = "üìÇ ƒêang x·ª≠ l√Ω file...";

            if (file.type === "application/pdf") {
                await handlePDF(file);
            } else {
                preview.src = URL.createObjectURL(file);
                await preview.decode();
                preprocess(preview);
                await runOCR();
            }
        };


        /* ================= PREPROCESS ================= */
        function preprocess(img) {
            const scale = 2; // R·∫§T QUAN TR·ªåNG
            canvas.width = img.naturalWidth * scale;
            canvas.height = img.naturalHeight * scale;

            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const d = imageData.data;

            // t√≠nh ng∆∞·ª°ng trung b√¨nh
            let sum = 0;
            for (let i = 0; i < d.length; i += 4) {
                sum += d[i];
            }
            let avg = sum / (d.length / 4);

            // adaptive threshold
            for (let i = 0; i < d.length; i += 4) {
                let g = d[i] * 0.299 + d[i + 1] * 0.587 + d[i + 2] * 0.114;
                let v = g > avg ? 255 : 0;
                d[i] = d[i + 1] = d[i + 2] = v;
            }

            ctx.putImageData(imageData, 0, 0);
        }

        /* ================= OCR ================= */
        async function runOCR() {
            status.innerText = "üîç OCR ƒëang x·ª≠ l√Ω...";

            try {
                const { data } = await Tesseract.recognize(
                    canvas,
                    "vie+eng",
                    {
                        tessedit_pageseg_mode: Tesseract.PSM.SPARSE_TEXT,
                        preserve_interword_spaces: 1,
                        logger: m => {
                            if (m.status === "recognizing text") {
                                status.innerText = `üîç OCR ${Math.round(m.progress * 100)}%`;
                            }
                        }
                    }
                );

                result.value = cleanText(data.text);
                status.innerText = "‚úÖ OCR ho√†n th√†nh";
            } catch (err) {
                status.innerText = "‚ùå OCR l·ªói";
                console.error(err);
            }
        }

        /* ================= CLEAN TEXT ================= */
        function cleanText(text) {
            return text
                // chu·∫©n h√≥a unicode
                .normalize("NFC")

                // thay k√Ω t·ª± OCR hay nh·∫ßm
                .replace(/[|]/g, "I")
                .replace(/[‚Äú‚Äù]/g, '"')
                .replace(/[‚Äò‚Äô]/g, "'")

                // b·ªè k√Ω t·ª± r√°c
                .replace(/[_~`]/g, "")
                .replace(/[^\S\r\n]{2,}/g, " ")

                // gh√©p ch·ªØ b·ªã t√°ch: T R U O N G ‚Üí TRUONG
                .replace(/\b([A-Z√Ä-·ª∏])\s+([A-Z√Ä-·ª∏])\s+([A-Z√Ä-·ª∏])\b/g, "$1$2$3")
                .replace(/\b([A-Z√Ä-·ª∏])\s+([A-Z√Ä-·ª∏])\b/g, "$1$2")

                // gh√©p s·ªë b·ªã t√°ch: 0 3 7 ‚Üí 037
                .replace(/\b(\d)\s+(\d)\s+(\d)\b/g, "$1$2$3")
                .replace(/\b(\d)\s+(\d)\b/g, "$1$2")

                // x√≥a d√≤ng qu√° ng·∫Øn (nhi·ªÖu)
                .split("\n")
                .map(line => line.trim())
                .filter(line => line.length > 2)
                .join("\n")

                // gom d√≤ng th·ª´a
                .replace(/\n{3,}/g, "\n\n")
                .trim();
        }

        async function handlePDF(file) {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

            let fullText = "";

            for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                status.innerText = `üìÑ ƒêang x·ª≠ l√Ω trang ${pageNum}/${pdf.numPages}`;

                const page = await pdf.getPage(pageNum);
                const viewport = page.getViewport({ scale: 2 });

                canvas.width = viewport.width;
                canvas.height = viewport.height;

                await page.render({
                    canvasContext: ctx,
                    viewport
                }).promise;

                // OCR t·ª´ng trang
                const { data } = await Tesseract.recognize(
                    canvas,
                    "vie+eng",
                    {
                        tessedit_pageseg_mode: Tesseract.PSM.SPARSE_TEXT,
                        preserve_interword_spaces: 1
                    }
                );

                fullText += `\n\n===== TRANG ${pageNum} =====\n`;
                fullText += cleanText(data.text);
            }

            result.value = fullText.trim();
            status.innerText = "‚úÖ OCR PDF ho√†n th√†nh";
        }


    </script>

</body>

</html>